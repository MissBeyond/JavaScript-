<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
    // apply 和 call 的使用
    // 作用：可以改变this的指向 
    // function f1(x,y) {
    //     console.log('结果是'+ (x+y) + this)
    //     return 1000
    // }
    // f1(10,20)//函数调用

    // console.log('==========')
    // // 此时的f1实际上是当成对象来使用，对象可以调用方法
    // // apply 和 call 方法也是函数的调用的方式 
    // f1.apply()
    // f1.call()
    // console.log('==========')
    // f1.apply(null)
    // f1.call(null)
    // // apply 和 call 方法中如果没有传入参数，或者传入的是null，那么调用该方法的函数对象中的this就是默认的window

    // f1.apply(null,[10,20])
    // f1.call(null,10, 20)
    // // apply 和 call 都可以让函数或者方法来调用，传入参数和函数自己调用的写法不一样，但是效果一样的
    // var result1 =f1.apply(null,[10,20])
    // var result2 =f1.call(null,10, 20)
    // console.log(result1)
    // console.log(result2)

    // function f1(x,y) {
    //     console.log('早上好'+(x+y) + this.age)
    // }
    // window.f1(10,20)
    // // obj 是一个对象
    // var obj = {
    //     age:10,
    //     sex:'男'
    // }
    // f1.apply(obj,[10,20])
    // console.dir(obj)
    // // f1.call(obj,10,20)
    // apply 和 call 可以改变this 的指向

    function Person(age,sex) {
        this.age = age
        this.sex = sex
    }
    Person.prototype.sayHi = function () {
        console.log('你好呀' + this.sex)
        return 100000
    }
    var per = new Person(10,'女')
    per.sayHi()

    function Student(name,sex) {
        this.name = name
        this.sex =sex
    }
    var stu = new Student('小明', '女')
    var r1 = per.sayHi.apply(stu,[10,20])
    var r2 = per.sayHi.call(stu,10,20)
    per.sayHi.call(stu,10,20)
    console.log(r1)
    console.log(r2)
    </script>
</body>
</html>